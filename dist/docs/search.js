window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "game", "modulename": "game", "kind": "module", "doc": "<p>This document provides a introduction to the documentation for how to play the game. Documentation for classes\navailable to players can be found to the left, and source code can be viewed from documentation as well.</p>\n\n<p><strong>About Board</strong></p>\n\n<p>Eacn turn, you will be given a <code>Board</code> (in <code>game.board</code>) instance, representing\na copy of the current game state without trapdoors.\nYou will also be given a callable <code>time_left()</code> function that, when called, will provide you\nwith the amount of time you have left for your turn in seconds. Trapdoor data is held\nby the game runner, so you will have to remember and set the trapdoors yourself via <code>set_trapdoor</code>.\nBefore then, any functions trying to get trapdoor data will not return anything valuable.</p>\n\n<p>Both <code>apply_move</code> and <code>forecast_move</code> end a turn and pass to the next player.\nAlso note that <code>apply_move</code> and <code>forecast_move</code> do not automatically\nreverse the perspective of the board - that is, functions will still call as if you are the player and your opponent is the\nenemy. If you want to call methods for your opponent on the next turn, either use the <code>enemy</code> parameter, call\n<code>Board.reverse_perspective()</code>, or pass the <code>reverse</code> flag into <code>apply_move</code> and <code>forecast_move</code>.</p>\n\n<p>Finally, remember that coordinates are returned in (x, y) form.</p>\n\n<p>We use A and B rather than Black and White.  Player A goes first and can (eventually) lay an egg at 0,0.</p>\n\n<p><strong>Getting Started</strong></p>\n\n<p>You will be creating a class called <code>PlayerAgent</code> that has a <code>play</code> method.  The state of the game will be passed as arguments to the <code>play</code> method.  Your <code>play</code> method will return an action, which is a tuple containing a direction and a move type, for example <code>(enums.Direction.UP, enums.MoveType.EGG)</code> would be an egg step in the upward direction.  (Note that UP, decrements the row because we draw the board with (0,0) in the top left corner.)</p>\n\n<p>Your <code>play</code> method will also get sensory data for the square you are about to leave: a list of tuples containing (hear, feel) booleans for each trapdoor.</p>\n\n<p>If you're lost about where to get started, we recommend that you take a look at\nthe Board functions, especially <code>apply_move</code>, <code>forecast_move</code>, and <code>get_valid_moves</code>,\nalongside <code>apply_move</code> and <code>forecast_move</code> in the <code>Board</code> class.</p>\n\n<p><strong>Extending the Board</strong></p>\n\n<p>The <code>Board</code> class provides basic, high-level ways to interact with the board.\nFor the purposes of this assignment, Board methods may be sufficient for your needs\ndepending on how you design your bot.\nYou can write your own methods that use <code>Board</code> as a parameter for more complex functionality,\nand you can even wrap the <code>Board</code> class in a class that you design.</p>\n\n<p>You can also use methods from the underlying classes that <code>Board</code> wraps,\nsuch as <code>Board</code> and <code>Chicken</code>. You can do this by accessing the <code>Board.game_board</code>\nvariable. It may be valuable to you to read through these some of these functions to understand\nhow the game runs at a lower level.</p>\n\n<p>Modify internal state variables for Board\ndirectly outside of functions at your own peril: you will have to understand\nhow the game operates through these functions, or else you risk modifying the board\nin ways you did not anticipate. If you want to extend these classes or use the internal classes,\nwe recommend that you at least read the documentation and if you're curious read the\nsource code alongside it.</p>\n"}, {"fullname": "game.board", "modulename": "game.board", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "game.board.manhattan_distance", "modulename": "game.board", "qualname": "manhattan_distance", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">p1</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">p2</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "game.board.Board", "modulename": "game.board", "qualname": "Board", "kind": "class", "doc": "<p>Board is the representation of the state of the match. It contains\nonly the state known to the player -- undiscovered trapdoors are not\nincluded in the Board (although found ones are).</p>\n\n<p>Any coordinates should be given to the board in the form of x, y.</p>\n\n<p>Check_validity is on by default for most functions, but slows\ndown execution. If a player is confident their actions are valid,\nthey can directly apply turns and moves with check_validity as false.</p>\n\n<p>Be wary that invalid actions/turns could lead to functions throwing\nerrors, so make sure to handle them with a try/except in case so that\nyour program doesn't crash. If an apply function throws an error,\nit is not guarenteed that the board state will be valid or that the state\nwill be the same as when the function started.</p>\n"}, {"fullname": "game.board.Board.__init__", "modulename": "game.board", "qualname": "Board.__init__", "kind": "function", "doc": "<p>Initializes the board with the specified game map and configuration options.</p>\n\n<p>Parameters:\n    game_map (game_map.GameMap): The map representing the game environment.\n    time_to_play (float, optional): The time limit for the game in seconds. Defaults to 20.\n    build_history (bool, optional): Whether to track the history of the game. Defaults to False.\n    copy (bool, optional): Whether to initialize a copy of the game game_map. Defaults to False.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">game_map</span><span class=\"p\">:</span> <span class=\"n\">game</span><span class=\"o\">.</span><span class=\"n\">game_map</span><span class=\"o\">.</span><span class=\"n\">GameMap</span>,</span><span class=\"param\">\t<span class=\"n\">time_to_play</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">20</span>,</span><span class=\"param\">\t<span class=\"n\">build_history</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">copy</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span>)</span>"}, {"fullname": "game.board.Board.game_map", "modulename": "game.board", "qualname": "Board.game_map", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "game.board.Board.is_valid_cell", "modulename": "game.board", "qualname": "Board.is_valid_cell", "kind": "function", "doc": "<p>Checks if the given coordinates are within the valid board boundaries.</p>\n\n<p>Parameters:\n    (x, y): The location to check.</p>\n\n<p>Returns:\n    (bool): True if the cell is valid, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">loc</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "game.board.Board.is_cell_in_enemy_turd_zone", "modulename": "game.board", "qualname": "Board.is_cell_in_enemy_turd_zone", "kind": "function", "doc": "<p>Checks if a specific cell is within the enemy's turd zone.</p>\n\n<p>Parameters:\n    loc: The (x,y) location of the cell.</p>\n\n<p>Returns:\n    (bool): True if the cell is within the enemy's turd zone, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">loc</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "game.board.Board.is_cell_blocked", "modulename": "game.board", "qualname": "Board.is_cell_blocked", "kind": "function", "doc": "<p>Checks if a specific cell is blocked for the given player.</p>\n\n<p>Parameters:\n    loc: The (x,y) location of the cell.</p>\n\n<p>Returns:\n    (bool): True if the cell is blocked or occupied by the enemy chicken, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">loc</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "game.board.Board.is_valid_direction", "modulename": "game.board", "qualname": "Board.is_valid_direction", "kind": "function", "doc": "<p>Checks if a direction is valid for the given player.</p>\n\n<p>Parameters:\n    dir (Direction | int): The direction to check.</p>\n\n<p>Returns:\n    (bool): True if the direction is valid, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"nb\">dir</span><span class=\"p\">:</span> <span class=\"n\">game</span><span class=\"o\">.</span><span class=\"n\">enums</span><span class=\"o\">.</span><span class=\"n\">Direction</span> <span class=\"o\">|</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.board.Board.is_valid_move", "modulename": "game.board", "qualname": "Board.is_valid_move", "kind": "function", "doc": "<p>Checks if a move is valid for the given player.</p>\n\n<p>Parameters:\n    dir (Direction | int): The direction of the move.\n    move_type (MoveType | int): The type of move (walk, egg, turd).</p>\n\n<p>Returns:\n    (bool): True if the move is valid, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"nb\">dir</span><span class=\"p\">:</span> <span class=\"n\">game</span><span class=\"o\">.</span><span class=\"n\">enums</span><span class=\"o\">.</span><span class=\"n\">Direction</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">move_type</span><span class=\"p\">:</span> <span class=\"n\">game</span><span class=\"o\">.</span><span class=\"n\">enums</span><span class=\"o\">.</span><span class=\"n\">MoveType</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">enemy</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.board.Board.get_valid_moves", "modulename": "game.board", "qualname": "Board.get_valid_moves", "kind": "function", "doc": "<p>Returns a list of all valid moves for the player or enemy.</p>\n\n<p>Parameters:\n    enemy (bool, optional): If True, returns valid moves for enemy; if False, returns for player.</p>\n\n<p>Returns:\n    (List[Tuple[Direction, MoveType]]): List of tuples containing valid direction and move type combinations.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">enemy</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">game</span><span class=\"o\">.</span><span class=\"n\">enums</span><span class=\"o\">.</span><span class=\"n\">Direction</span><span class=\"p\">,</span> <span class=\"n\">game</span><span class=\"o\">.</span><span class=\"n\">enums</span><span class=\"o\">.</span><span class=\"n\">MoveType</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "game.board.Board.can_lay_egg", "modulename": "game.board", "qualname": "Board.can_lay_egg", "kind": "function", "doc": "<p>Checks if the player can lay an egg at their current location.</p>\n\n<p>Parameters:</p>\n\n<p>Returns:\n    (bool): True if an egg can be laid, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.board.Board.can_lay_egg_at_loc", "modulename": "game.board", "qualname": "Board.can_lay_egg_at_loc", "kind": "function", "doc": "<p>Checks if the player can lay an egg at a specific location.</p>\n\n<p>Parameters:\n    x (int): The x-coordinate of the location.\n    y (int): The y-coordinate of the location.</p>\n\n<p>Returns:\n    (bool): True if an egg can be laid at that location, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">loc</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.board.Board.can_lay_turd", "modulename": "game.board", "qualname": "Board.can_lay_turd", "kind": "function", "doc": "<p>Checks if the player can lay a turd at their current location.</p>\n\n<p>Returns:\n    (bool): True if a turd can be laid, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.board.Board.can_lay_turd_at_loc", "modulename": "game.board", "qualname": "Board.can_lay_turd_at_loc", "kind": "function", "doc": "<p>Checks if the player can lay a turd at a specific location.</p>\n\n<p>Parameters:\n    x (int): The x-coordinate of the location.\n    y (int): The y-coordinate of the location.</p>\n\n<p>Returns:\n    (bool): True if a turd can be laid at that location, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">loc</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.board.Board.apply_move", "modulename": "game.board", "qualname": "Board.apply_move", "kind": "function", "doc": "<p>Applies a move to the board for the specified player.</p>\n\n<p>Parameters:\n    dir (Direction | int): The direction of the move.\n    move_type (MoveType | int): The type of move (walk, egg, turd).\n    timer (float, optional): Time taken for the move in seconds. Defaults to 0.\n    check_ok (bool, optional): If True, validates the move before applying; if False, skips validation. Defaults to True.</p>\n\n<p>Returns:\n    (bool): True if the move was successfully applied, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"nb\">dir</span><span class=\"p\">:</span> <span class=\"n\">game</span><span class=\"o\">.</span><span class=\"n\">enums</span><span class=\"o\">.</span><span class=\"n\">Direction</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">move_type</span><span class=\"p\">:</span> <span class=\"n\">game</span><span class=\"o\">.</span><span class=\"n\">enums</span><span class=\"o\">.</span><span class=\"n\">MoveType</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">timer</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">check_ok</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.board.Board.end_turn", "modulename": "game.board", "qualname": "Board.end_turn", "kind": "function", "doc": "<p>Ends the current turn and updates game state.</p>\n\n<p>Parameters:\n    move_type (MoveType): The type of move that was made.\n    timer (float, optional): Time taken for the turn in seconds. Defaults to 0.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">move_type</span><span class=\"p\">:</span> <span class=\"n\">game</span><span class=\"o\">.</span><span class=\"n\">enums</span><span class=\"o\">.</span><span class=\"n\">MoveType</span>, </span><span class=\"param\"><span class=\"n\">timer</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.board.Board.check_win", "modulename": "game.board", "qualname": "Board.check_win", "kind": "function", "doc": "<p>Checks if the game has been won and sets the winner accordingly.</p>\n\n<p>Parameters:\n    timeout_bounds (float, optional): The time threshold in seconds for determining timeout ties. Defaults to 0.5.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">timeout_bounds</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.board.Board.is_game_over", "modulename": "game.board", "qualname": "Board.is_game_over", "kind": "function", "doc": "<p>Checks if the game is over.</p>\n\n<p>Returns:\n    (bool): True if the game is over, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.board.Board.forecast_move", "modulename": "game.board", "qualname": "Board.forecast_move", "kind": "function", "doc": "<p>Creates a copy of the board with a forecasted move applied.</p>\n\n<p>Parameters:\n    dir (Direction | int): The direction of the move.\n    move_type (MoveType | int): The type of move (walk, egg, turd).\n    check_ok (bool, optional): If True, validates the move before applying; if False, skips validation. Defaults to True.</p>\n\n<p>Returns:\n    (Board): A new Board object with the move applied, or None if the move is invalid.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"nb\">dir</span><span class=\"p\">:</span> <span class=\"n\">game</span><span class=\"o\">.</span><span class=\"n\">enums</span><span class=\"o\">.</span><span class=\"n\">Direction</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">move_type</span><span class=\"p\">:</span> <span class=\"n\">game</span><span class=\"o\">.</span><span class=\"n\">enums</span><span class=\"o\">.</span><span class=\"n\">MoveType</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">check_ok</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.board.Board.set_found_trapdoors", "modulename": "game.board", "qualname": "Board.set_found_trapdoors", "kind": "function", "doc": "<p>Sets a trapdoor at the specified location and updates sampling masks if randomization is enabled.</p>\n\n<p>Parameters:\n    x (int): The x-coordinate for the trapdoor.\n    y (int): The y-coordinate for the trapdoor.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">found_trapdoors</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.board.Board.get_copy", "modulename": "game.board", "qualname": "Board.get_copy", "kind": "function", "doc": "<p>Creates a deep copy of the current board.</p>\n\n<p>Parameters:\n    build_history (bool, optional): Whether the copy should track history. Defaults to False.</p>\n\n<p>Returns:\n    (Board): A new Board object with the same state as the current one.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">build_history</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">asymmetric</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.board.Board.has_moves_left", "modulename": "game.board", "qualname": "Board.has_moves_left", "kind": "function", "doc": "<p>Checks if the player has any valid moves remaining.</p>\n\n<p>Returns:\n    (bool): True if there are valid moves remaining, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">enemy</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.board.Board.set_build_history", "modulename": "game.board", "qualname": "Board.set_build_history", "kind": "function", "doc": "<p>Sets whether the history of the game should be recorded.</p>\n\n<p>Parameters:\n    build_history (bool): Whether to track the game history. True to record, False to not record.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">build_history</span><span class=\"p\">:</span> <span class=\"nb\">bool</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.board.Board.set_winner", "modulename": "game.board", "qualname": "Board.set_winner", "kind": "function", "doc": "<p>Sets the winner and the reason for the game's outcome.</p>\n\n<p>Parameters:\n    result (Result): The winner of the game.\n    reason (WinReason): The reason for the outcome.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">result</span><span class=\"p\">:</span> <span class=\"n\">game</span><span class=\"o\">.</span><span class=\"n\">enums</span><span class=\"o\">.</span><span class=\"n\">Result</span>, </span><span class=\"param\"><span class=\"n\">reason</span><span class=\"p\">:</span> <span class=\"n\">game</span><span class=\"o\">.</span><span class=\"n\">enums</span><span class=\"o\">.</span><span class=\"n\">WinReason</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.board.Board.get_winner", "modulename": "game.board", "qualname": "Board.get_winner", "kind": "function", "doc": "<p>Returns the winner of the game.</p>\n\n<p>Returns:\n    (Result): The winner of the game.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">game</span><span class=\"o\">.</span><span class=\"n\">enums</span><span class=\"o\">.</span><span class=\"n\">Result</span>:</span></span>", "funcdef": "def"}, {"fullname": "game.board.Board.get_win_reason", "modulename": "game.board", "qualname": "Board.get_win_reason", "kind": "function", "doc": "<p>Returns the string explaining the reason why the game was won.</p>\n\n<p>Returns:\n    (str): The reason for the game's outcome.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "game.board.Board.get_history", "modulename": "game.board", "qualname": "Board.get_history", "kind": "function", "doc": "<p>Get a dictionary representation for the renderer.</p>\n\n<p>Returns:\n    (dict): A dictionary representing the game history.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "game.board.Board.reverse_perspective", "modulename": "game.board", "qualname": "Board.reverse_perspective", "kind": "function", "doc": "<p>Reverses the perspective from player to enemy or vice versa.\nThis swaps all player and enemy references internally.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.chicken", "modulename": "game.chicken", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "game.chicken.Chicken", "modulename": "game.chicken", "qualname": "Chicken", "kind": "class", "doc": "<p>This class represents a chicken.</p>\n"}, {"fullname": "game.chicken.Chicken.__init__", "modulename": "game.chicken", "qualname": "Chicken.__init__", "kind": "function", "doc": "<p>Initializes the Chicken object with copy flag.</p>\n\n<p>Parameters:\n    max_turds (int, optional): Maximum number of turds the chicken can place. Defaults to 0.\n    copy (bool, optional): If True, initializes as an empty copy; if False, initializes with default values. Defaults to False.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">max_turds</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">copy</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span>)</span>"}, {"fullname": "game.chicken.Chicken.start", "modulename": "game.chicken", "qualname": "Chicken.start", "kind": "function", "doc": "<p>Initializes the chicken's starting position and parity.</p>\n\n<p>Parameters:\n    start_loc (Tuple[int, int]): The (x, y) coordinates of the starting location.\n    even_chicken (int): The parity indicator (0 or 1) that determines which cells the chicken can lay eggs on.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">start_loc</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">even_chicken</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.chicken.Chicken.is_player_a", "modulename": "game.chicken", "qualname": "Chicken.is_player_a", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "game.chicken.Chicken.get_spawn", "modulename": "game.chicken", "qualname": "Chicken.get_spawn", "kind": "function", "doc": "<p>Returns a copy of the chicken's spawn location.</p>\n\n<p>Returns:\n    Tuple[int, int]: containing the (x, y) coordinates of the spawn location.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "game.chicken.Chicken.get_location", "modulename": "game.chicken", "qualname": "Chicken.get_location", "kind": "function", "doc": "<p>Returns a copy of the chicken's current location.</p>\n\n<p>Returns:\n    (Tuple[int, int]): tuple containing the (x, y) coordinates of the current location.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "game.chicken.Chicken.increment_eggs_laid", "modulename": "game.chicken", "qualname": "Chicken.increment_eggs_laid", "kind": "function", "doc": "<p>Increments the count of eggs laid by the chicken.</p>\n\n<p>Parameters:\n    eggs (int, optional): Number of eggs to add to the count. Defaults to 1.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">eggs</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.chicken.Chicken.reset_location", "modulename": "game.chicken", "qualname": "Chicken.reset_location", "kind": "function", "doc": "<p>Resets the chicken's location back to its spawn point.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.chicken.Chicken.can_lay_egg", "modulename": "game.chicken", "qualname": "Chicken.can_lay_egg", "kind": "function", "doc": "<p>Checks if the chicken can lay an egg at the specified location based on parity.</p>\n\n<p>Parameters:\n    x (int): The x-coordinate of the location.\n    y (int): The y-coordinate of the location.</p>\n\n<p>Returns:\n    (bool): True if the chicken can lay an egg at that location, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">loc</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.chicken.Chicken.decrement_turds", "modulename": "game.chicken", "qualname": "Chicken.decrement_turds", "kind": "function", "doc": "<p>Decrements the count of turds remaining.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.chicken.Chicken.get_turds_left", "modulename": "game.chicken", "qualname": "Chicken.get_turds_left", "kind": "function", "doc": "<p>Returns the number of turds remaining.</p>\n\n<p>Returns:\n    (int): Number of turds left.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "game.chicken.Chicken.get_turds_placed", "modulename": "game.chicken", "qualname": "Chicken.get_turds_placed", "kind": "function", "doc": "<p>Returns the number of turds that have been placed.</p>\n\n<p>Returns:\n    (int): Number of turds placed.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "game.chicken.Chicken.get_eggs_laid", "modulename": "game.chicken", "qualname": "Chicken.get_eggs_laid", "kind": "function", "doc": "<p>Returns the number of eggs laid by the chicken.</p>\n\n<p>Returns:\n    (int): Number of eggs laid.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.chicken.Chicken.get_next_loc", "modulename": "game.chicken", "qualname": "Chicken.get_next_loc", "kind": "function", "doc": "<p>Returns the next location if the chicken moves in the specified direction. Does not apply the move.</p>\n\n<p>Parameters:\n    dir (Direction | int): The direction to move.\n    loc (Tuple[int, int]): The starting location. If None, uses current location. Defaults to None.</p>\n\n<p>Returns:\n    (np.ndarray): Array containing the (x, y) coordinates of the next location, or None if direction is invalid.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"nb\">dir</span><span class=\"o\">=</span><span class=\"n\">game</span><span class=\"o\">.</span><span class=\"n\">enums</span><span class=\"o\">.</span><span class=\"n\">Direction</span> <span class=\"o\">|</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">loc</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "game.chicken.Chicken.apply_dir", "modulename": "game.chicken", "qualname": "Chicken.apply_dir", "kind": "function", "doc": "<p>Applies a direction to move the chicken and updates its location.</p>\n\n<p>Parameters:\n    dir (Direction | int): The direction to move.</p>\n\n<p>Returns:\n    (Tuple[int, int]): Array containing the new (x, y) coordinates, or None if direction is invalid.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"nb\">dir</span><span class=\"o\">=</span><span class=\"n\">game</span><span class=\"o\">.</span><span class=\"n\">enums</span><span class=\"o\">.</span><span class=\"n\">Direction</span> <span class=\"o\">|</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "game.chicken.Chicken.lay_egg", "modulename": "game.chicken", "qualname": "Chicken.lay_egg", "kind": "function", "doc": "<p>Lays an egg at the chicken's current location and increments the egg count.</p>\n\n<p>Returns:\n    (Tuple[int, int]): Array containing the (x, y) coordinates where the egg was laid.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.chicken.Chicken.drop_turd", "modulename": "game.chicken", "qualname": "Chicken.drop_turd", "kind": "function", "doc": "<p>Drops a turd at the chicken's current location and decrements the turd count.</p>\n\n<p>Returns:\n    (Tuple[int, int]): Array containing the (x, y) coordinates where the turd was dropped.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.chicken.Chicken.has_turds_left", "modulename": "game.chicken", "qualname": "Chicken.has_turds_left", "kind": "function", "doc": "<p>Checks if the chicken has turds remaining.</p>\n\n<p>Returns:\n    (bool): True if there are turds remaining, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.chicken.Chicken.prob_senses_if_trapdoor_were_at", "modulename": "game.chicken", "qualname": "Chicken.prob_senses_if_trapdoor_were_at", "kind": "function", "doc": "<p>Returns a tuple representing the probability of the player (hearing, feeling) the trapdoor if it were at x,y.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">did_hear</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>, </span><span class=\"param\"><span class=\"n\">did_feel</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.chicken.Chicken.get_copy", "modulename": "game.chicken", "qualname": "Chicken.get_copy", "kind": "function", "doc": "<p>Return a deep copy of the chicken.</p>\n\n<p>Returns:\n    (Chicken): A deep copy of the current chicken object.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">game</span><span class=\"o\">.</span><span class=\"n\">chicken</span><span class=\"o\">.</span><span class=\"n\">Chicken</span>:</span></span>", "funcdef": "def"}, {"fullname": "game.enums", "modulename": "game.enums", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "game.enums.Result", "modulename": "game.enums", "qualname": "Result", "kind": "class", "doc": "<p></p>\n", "bases": "enum.IntEnum"}, {"fullname": "game.enums.Result.PLAYER", "modulename": "game.enums", "qualname": "Result.PLAYER", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Result.PLAYER: 0&gt;"}, {"fullname": "game.enums.Result.ENEMY", "modulename": "game.enums", "qualname": "Result.ENEMY", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Result.ENEMY: 1&gt;"}, {"fullname": "game.enums.Result.TIE", "modulename": "game.enums", "qualname": "Result.TIE", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Result.TIE: 2&gt;"}, {"fullname": "game.enums.Result.ERROR", "modulename": "game.enums", "qualname": "Result.ERROR", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Result.ERROR: 3&gt;"}, {"fullname": "game.enums.ResultArbiter", "modulename": "game.enums", "qualname": "ResultArbiter", "kind": "class", "doc": "<p></p>\n", "bases": "enum.IntEnum"}, {"fullname": "game.enums.ResultArbiter.PLAYER_A", "modulename": "game.enums", "qualname": "ResultArbiter.PLAYER_A", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ResultArbiter.PLAYER_A: 0&gt;"}, {"fullname": "game.enums.ResultArbiter.PLAYER_B", "modulename": "game.enums", "qualname": "ResultArbiter.PLAYER_B", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ResultArbiter.PLAYER_B: 1&gt;"}, {"fullname": "game.enums.ResultArbiter.TIE", "modulename": "game.enums", "qualname": "ResultArbiter.TIE", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ResultArbiter.TIE: 2&gt;"}, {"fullname": "game.enums.ResultArbiter.ERROR", "modulename": "game.enums", "qualname": "ResultArbiter.ERROR", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;ResultArbiter.ERROR: 3&gt;"}, {"fullname": "game.enums.Direction", "modulename": "game.enums", "qualname": "Direction", "kind": "class", "doc": "<p></p>\n", "bases": "enum.IntEnum"}, {"fullname": "game.enums.Direction.UP", "modulename": "game.enums", "qualname": "Direction.UP", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Direction.UP: 0&gt;"}, {"fullname": "game.enums.Direction.RIGHT", "modulename": "game.enums", "qualname": "Direction.RIGHT", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Direction.RIGHT: 1&gt;"}, {"fullname": "game.enums.Direction.DOWN", "modulename": "game.enums", "qualname": "Direction.DOWN", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Direction.DOWN: 2&gt;"}, {"fullname": "game.enums.Direction.LEFT", "modulename": "game.enums", "qualname": "Direction.LEFT", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Direction.LEFT: 3&gt;"}, {"fullname": "game.enums.loc_after_direction", "modulename": "game.enums", "qualname": "loc_after_direction", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">loc</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"nb\">dir</span><span class=\"p\">:</span> <span class=\"n\">game</span><span class=\"o\">.</span><span class=\"n\">enums</span><span class=\"o\">.</span><span class=\"n\">Direction</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "game.enums.MoveType", "modulename": "game.enums", "qualname": "MoveType", "kind": "class", "doc": "<p></p>\n", "bases": "enum.IntEnum"}, {"fullname": "game.enums.MoveType.PLAIN", "modulename": "game.enums", "qualname": "MoveType.PLAIN", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;MoveType.PLAIN: 0&gt;"}, {"fullname": "game.enums.MoveType.EGG", "modulename": "game.enums", "qualname": "MoveType.EGG", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;MoveType.EGG: 1&gt;"}, {"fullname": "game.enums.MoveType.TURD", "modulename": "game.enums", "qualname": "MoveType.TURD", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;MoveType.TURD: 2&gt;"}, {"fullname": "game.enums.Cell", "modulename": "game.enums", "qualname": "Cell", "kind": "class", "doc": "<p></p>\n", "bases": "enum.IntEnum"}, {"fullname": "game.enums.Cell.SPACE", "modulename": "game.enums", "qualname": "Cell.SPACE", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Cell.SPACE: 0&gt;"}, {"fullname": "game.enums.Cell.PLAYER_A_EGG", "modulename": "game.enums", "qualname": "Cell.PLAYER_A_EGG", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Cell.PLAYER_A_EGG: 1&gt;"}, {"fullname": "game.enums.Cell.PLAYER_A_TURD", "modulename": "game.enums", "qualname": "Cell.PLAYER_A_TURD", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Cell.PLAYER_A_TURD: 2&gt;"}, {"fullname": "game.enums.Cell.PLAYER_B_EGG", "modulename": "game.enums", "qualname": "Cell.PLAYER_B_EGG", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Cell.PLAYER_B_EGG: 3&gt;"}, {"fullname": "game.enums.Cell.PLAYER_B_TURD", "modulename": "game.enums", "qualname": "Cell.PLAYER_B_TURD", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Cell.PLAYER_B_TURD: 4&gt;"}, {"fullname": "game.enums.Cell.TRAPDOOR", "modulename": "game.enums", "qualname": "Cell.TRAPDOOR", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Cell.TRAPDOOR: 5&gt;"}, {"fullname": "game.enums.WinReason", "modulename": "game.enums", "qualname": "WinReason", "kind": "class", "doc": "<p></p>\n", "bases": "enum.IntEnum"}, {"fullname": "game.enums.WinReason.EGGS_LAID", "modulename": "game.enums", "qualname": "WinReason.EGGS_LAID", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;WinReason.EGGS_LAID: 0&gt;"}, {"fullname": "game.enums.WinReason.BLOCKING_END", "modulename": "game.enums", "qualname": "WinReason.BLOCKING_END", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;WinReason.BLOCKING_END: 1&gt;"}, {"fullname": "game.enums.WinReason.TIMEOUT", "modulename": "game.enums", "qualname": "WinReason.TIMEOUT", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;WinReason.TIMEOUT: 2&gt;"}, {"fullname": "game.enums.WinReason.INVALID_TURN", "modulename": "game.enums", "qualname": "WinReason.INVALID_TURN", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;WinReason.INVALID_TURN: 3&gt;"}, {"fullname": "game.enums.WinReason.CODE_CRASH", "modulename": "game.enums", "qualname": "WinReason.CODE_CRASH", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;WinReason.CODE_CRASH: 4&gt;"}, {"fullname": "game.enums.WinReason.MEMORY_ERROR", "modulename": "game.enums", "qualname": "WinReason.MEMORY_ERROR", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;WinReason.MEMORY_ERROR: 5&gt;"}, {"fullname": "game.enums.WinReason.FAILED_INIT", "modulename": "game.enums", "qualname": "WinReason.FAILED_INIT", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;WinReason.FAILED_INIT: 6&gt;"}, {"fullname": "game.game_map", "modulename": "game.game_map", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "game.game_map.prob_hear", "modulename": "game.game_map", "qualname": "prob_hear", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">delta_x</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">delta_y</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.game_map.prob_feel", "modulename": "game.game_map", "qualname": "prob_feel", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">delta_x</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">delta_y</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.game_map.GameMap", "modulename": "game.game_map", "qualname": "GameMap", "kind": "class", "doc": "<p>GameMap is an internal utility class used by board to initialize\nconstants and store immutable map data for the board. Also used\nto generate trapdoors. Do not use the functions in this class, they\nwill not be helpful to you. If you want to use the class variables,\nyou may by accessing them through\nthe game_board.game_map</p>\n"}, {"fullname": "game.game_map.GameMap.MAP_SIZE", "modulename": "game.game_map", "qualname": "GameMap.MAP_SIZE", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "game.game_map.GameMap.MAX_TRAPDOOR_DIST_FROM_CENTER", "modulename": "game.game_map", "qualname": "GameMap.MAX_TRAPDOOR_DIST_FROM_CENTER", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "game.game_map.GameMap.NUM_TRAPDOORS_PER_TEAM", "modulename": "game.game_map", "qualname": "GameMap.NUM_TRAPDOORS_PER_TEAM", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "game.game_map.GameMap.MAX_TURDS", "modulename": "game.game_map", "qualname": "GameMap.MAX_TURDS", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "game.game_map.GameMap.CORNER_REWARD", "modulename": "game.game_map", "qualname": "GameMap.CORNER_REWARD", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "game.game_map.GameMap.TRAPDOOR_PENALTY", "modulename": "game.game_map", "qualname": "GameMap.TRAPDOOR_PENALTY", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "game.game_map.GameMap.reflect", "modulename": "game.game_map", "qualname": "GameMap.reflect", "kind": "function", "doc": "<p>Reflects coordinates across the map given a type of symmetry.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">coords</span>, </span><span class=\"param\"><span class=\"n\">symmetry</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.history", "modulename": "game.history", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "game.history.History", "modulename": "game.history", "qualname": "History", "kind": "class", "doc": "<p>Internal utility for recording history used only by the game runner. \nDo not call these functions, they will not be helpful to you.</p>\n"}, {"fullname": "game.history.History.pos", "modulename": "game.history", "qualname": "History.pos", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "game.history.History.left_behind_enums", "modulename": "game.history", "qualname": "History.left_behind_enums", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "game.history.History.a_eggs_laid", "modulename": "game.history", "qualname": "History.a_eggs_laid", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "game.history.History.b_eggs_laid", "modulename": "game.history", "qualname": "History.b_eggs_laid", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "game.history.History.a_turds_left", "modulename": "game.history", "qualname": "History.a_turds_left", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "game.history.History.b_turds_left", "modulename": "game.history", "qualname": "History.b_turds_left", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "game.history.History.a_time_left", "modulename": "game.history", "qualname": "History.a_time_left", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "game.history.History.b_time_left", "modulename": "game.history", "qualname": "History.b_time_left", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "game.history.History.a_moves_left", "modulename": "game.history", "qualname": "History.a_moves_left", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "game.history.History.b_moves_left", "modulename": "game.history", "qualname": "History.b_moves_left", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "game.history.History.trapdoor_triggered", "modulename": "game.history", "qualname": "History.trapdoor_triggered", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "game.history.History.record_trapdoor", "modulename": "game.history", "qualname": "History.record_trapdoor", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">trigger_trap</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.history.History.record_round_update", "modulename": "game.history", "qualname": "History.record_round_update", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">loc</span>,</span><span class=\"param\">\t<span class=\"n\">move_type</span>,</span><span class=\"param\">\t<span class=\"n\">eggs_laid_a</span>,</span><span class=\"param\">\t<span class=\"n\">eggs_laid_b</span>,</span><span class=\"param\">\t<span class=\"n\">turds_left_a</span>,</span><span class=\"param\">\t<span class=\"n\">turds_left_b</span>,</span><span class=\"param\">\t<span class=\"n\">time_left_a</span>,</span><span class=\"param\">\t<span class=\"n\">time_left_b</span>,</span><span class=\"param\">\t<span class=\"n\">moves_left_a</span>,</span><span class=\"param\">\t<span class=\"n\">moves_left_b</span>,</span><span class=\"param\">\t<span class=\"n\">is_as_turn</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.trapdoor_manager", "modulename": "game.trapdoor_manager", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "game.trapdoor_manager.delta_locs", "modulename": "game.trapdoor_manager", "qualname": "delta_locs", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">loc_a</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">loc_b</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "game.trapdoor_manager.choose_trapdoor", "modulename": "game.trapdoor_manager", "qualname": "choose_trapdoor", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">weights</span>, </span><span class=\"param\"><span class=\"n\">parity</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "game.trapdoor_manager.TrapdoorManager", "modulename": "game.trapdoor_manager", "qualname": "TrapdoorManager", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "game.trapdoor_manager.TrapdoorManager.__init__", "modulename": "game.trapdoor_manager", "qualname": "TrapdoorManager.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">game_map</span><span class=\"p\">:</span> <span class=\"n\">game</span><span class=\"o\">.</span><span class=\"n\">game_map</span><span class=\"o\">.</span><span class=\"n\">GameMap</span></span>)</span>"}, {"fullname": "game.trapdoor_manager.TrapdoorManager.game_map", "modulename": "game.trapdoor_manager", "qualname": "TrapdoorManager.game_map", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "game.trapdoor_manager.TrapdoorManager.spawns", "modulename": "game.trapdoor_manager", "qualname": "TrapdoorManager.spawns", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "game.trapdoor_manager.TrapdoorManager.trapdoors", "modulename": "game.trapdoor_manager", "qualname": "TrapdoorManager.trapdoors", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "game.trapdoor_manager.TrapdoorManager.choose_spawns", "modulename": "game.trapdoor_manager", "qualname": "TrapdoorManager.choose_spawns", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.trapdoor_manager.TrapdoorManager.choose_trapdoors", "modulename": "game.trapdoor_manager", "qualname": "TrapdoorManager.choose_trapdoors", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.trapdoor_manager.TrapdoorManager.sample_trapdoors", "modulename": "game.trapdoor_manager", "qualname": "TrapdoorManager.sample_trapdoors", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">loc</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "game.trapdoor_manager.TrapdoorManager.is_trapdoor", "modulename": "game.trapdoor_manager", "qualname": "TrapdoorManager.is_trapdoor", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">loc</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "game.trapdoor_manager.TrapdoorManager.get_trapdoors", "modulename": "game.trapdoor_manager", "qualname": "TrapdoorManager.get_trapdoors", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "game.trapdoor_manager.TrapdoorManager.get_spawns", "modulename": "game.trapdoor_manager", "qualname": "TrapdoorManager.get_spawns", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();